#!/bin/bash

# Source prompt colors/symbols
if [ -f ~/.dotfiles/_promptcolors ];then
	. ~/.dotfiles/_promptcolors
fi

git_prompt() {

	hash git 2>/dev/null || return # git not found

	local git_eng="env LANG=C git"   # force git output in English to make our work easier

	# get current branch name or short SHA1 hash for detached head
	local branch="$($git_eng symbolic-ref --short HEAD 2>/dev/null || $git_eng describe --tags --always 2>/dev/null)"
	[ -n "$branch" ] || return  # git branch not found

	local marks

	# scan first two lines of output from `git status`
	while IFS= read -r line; do
		if [[ $line =~ ^'##' ]]; then # header line
			[[ $line =~ ahead\ ([0-9]+) ]] && marks+=" $GIT_NEED_PUSH_SYMBOL${BASH_REMATCH[1]}"
			[[ $line =~ behind\ ([0-9]+) ]] && marks+=" $GIT_NEED_PULL_SYMBOL${BASH_REMATCH[1]}"
		else # branch is modified if output contains more lines after the header line
			marks=" $GIT_BRANCH_CHANGED_SYMBOL$marks"
			break
		fi

		done < <($git_eng status --porcelain --branch)  # note the space between the two <

		# print the git branch segment without a trailing newline
     printf " [ $branch$marks ] "
}

git_prompt2() {
	local s='';
	local branchName='';

	# Check if the current directory is in a Git repository.
	if [ $(git rev-parse --is-inside-work-tree &>/dev/null; echo "${?}") == '0' ]; then

		# check if the current directory is in .git before running git checks
		if [ "$(git rev-parse --is-inside-git-dir 2> /dev/null)" == 'false' ]; then

			# Ensure the index is up to date.
			git update-index --really-refresh -q &>/dev/null;

			# Check for uncommitted changes in the index.
			if ! $(git diff --quiet --ignore-submodules --cached); then
				s+='+';
			fi;

			# Check for unstaged changes.
			if ! $(git diff-files --quiet --ignore-submodules --); then
				s+='!';
			fi;

			# Check for untracked files.
			if [ -n "$(git ls-files --others --exclude-standard)" ]; then
				s+='?';
			fi;

			# Check for stashed files.
			if $(git rev-parse --verify refs/stash &>/dev/null); then
				s+='$';
			fi;

		fi;

		# Get the short symbolic ref.
		# If HEAD isn't a symbolic ref, get the short SHA for the latest commit
		# Otherwise, just give up.
		branchName="$(git symbolic-ref --quiet --short HEAD 2> /dev/null || \
			git rev-parse --short HEAD 2> /dev/null || \
			echo '(unknown)')";

		[ -n "${s}" ] && s=" ${s}";

		echo -e "[ ${1}${branchName}${2}${s} ]";
	else
		return;
	fi;
}

# Set a color for last exit
lastexitcolor() {
if [ $? -eq 0 ]; then
	local EXITCOLOR_BG="$BG_GREEN"
else
	local EXITCOLOR_BG="$BG_RED"
fi

echo "$EXITCOLOR_BG"
}


# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color|*-256color) color_prompt=yes;;
esac

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
  # We have color support; assume it's compliant with Ecma-48
  # (ISO/IEC-6429). (Lack of such support is extremely rare, and such
  # a case would tend to support setf rather than setaf.)
  color_prompt=yes
    else
  color_prompt=
    fi
fi

