#!/bin/bash

# Source prompt colors/symbols
if [ -f ~/.dotfiles/bash/_promptcolors ];then
	. ~/.dotfiles/bash/_promptcolors
fi

git_prompt() {

hash git 2>/dev/null || return # git not found

local git_eng="env LANG=C git"   # force git output in English to make our work easier

# get current branch name
local ref=$($git_eng symbolic-ref --short HEAD 2>/dev/null)

# Check if branch or use tag/SHA
if [[ -n "$ref" ]]; then
	# prepend branch symbol
	ref="$SYMBOL_GIT_BRANCH $ref"
else
  # get tag name or short unique hash
	ref=$($git_eng describe --tags --always 2>/dev/null)
fi

[[ -n "$ref" ]] || return  # not a git repo

#Git Fetch sequence:
# Last Reflog: Last time upstream was updated
# Last Fetch: Last time fetch/pull was ATTEMPTED
# Between the two can identify when last updated or attempted a fetch.
MaxFetchSeconds=600
upstream=$(git rev-parse --abbrev-ref "@{upstream}")
gitdir=$(git rev-parse --git-dir)
if [[ $OSTYPE == darwin* ]]; then
	OSX=true
fi

lastreflog=$(git reflog show --date=unix $upstream -n1 | grep -o "{.*}" | tr -d '{}')
if [ -z "$lastreflog" ]; then
	if [ $OSX ]; then
  	lastreflog=$(date -j -v-${MaxFetchSeconds}S +%s)
	else
		lastreflog=$(date --date "-${MaxFetchSeconds} sec")
	fi
fi

if [ $OSX ]; then
	lastfetch=$(stat -f "%m" $gitdir/FETCH_HEAD)
else
	lastfetch=$(date +%s -r $gitdir/FETCH_HEAD)
fi

TimeSinceReflog=$(( $(date +%s) - $lastreflog ))
TimeSinceFetch=$(( $(date +%s) - $lastfetch ))
#echo "Time since last reflog: $TimeSinceReflog"
#echo "Time since last fetch: $TimeSinceFetch"
if [ "$TimeSinceReflog" -gt "$MaxFetchSeconds" ] && [ "$TimeSinceFetch" -gt "$MaxFetchSeconds" ]; then
	git fetch --all > /dev/null
fi

#Identify stashes
stashes=$(git stash list 2>/dev/null)
if [[ -n "$stashes" ]]; then
	git_stashed_count=`printf "$stashes" | grep -c ^`
fi

#Parse `git status --porcelain --branch` output
while IFS= read -r line; do
	if [[ $line =~ ^'##' ]]; then # header line

		#Identify number of commits ahead
		if [[ $line =~ ahead\ ([0-9]+) ]]; then 
			marks+=" $SYMBOL_GIT_PUSH"
			#style number as GREEN
			marks+="\e[32m";marks+="${BASH_REMATCH[1]}";marks+="\e[m"
		fi

		#Identify number of commits behind
		if [[ $line =~ behind\ ([0-9]+) ]]; then
			marks+=" $SYMBOL_GIT_PULL"
			#style number as YELLOW
			marks+="\e[33m";marks+="${BASH_REMATCH[1]}";marks+="\e[m"
		fi

	#Identify Added/Untracked files
	elif [[ $line =~ ^'A'[[:blank:]][[:blank:]] ]]; then
		git_index_added_count=$((git_index_added_count + 1))
	elif [[ $line =~ ^'??'[[:blank:]] ]]; then
		git_untracked_count=$((git_untracked_count + 1))

	#Identify Modified files
	elif [[ $line =~ ^'MM'[[:blank:]] ]]; then
		git_index_modified_count=$((git_index_modified_count + 1))
		git_modified_count=$((git_modified_count + 1))
	elif [[ $line =~ ^'M'[[:blank:]][[:blank:]] ]]; then
		git_index_modified_count=$((git_index_modified_count + 1))
	elif [[ $line =~ ^[[:blank:]]'M'[[:blank:]] ]]; then
		git_modified_count=$((git_modified_count + 1))

	#Identify Deleted files
	elif [[ $line =~ ^'D'[[:blank:]][[:blank:]] ]]; then
		git_index_deleted_count=$((git_index_deleted_count + 1))
	elif [[ $line =~ ^[[:blank:]]'D'[[:blank:]] ]]; then
		git_deleted_count=$((git_deleted_count + 1))

	fi

done < <($git_eng status --porcelain --branch 2>/dev/null)  # note the space between the two <

if [ "$git_index_added_count" ]; then
	marks+=" \e[97m";marks+="Ai:";marks+="\e[m"
	# style count as LIGHT GREEN
	marks+="\e[92m";marks+="$git_index_added_count";marks+="\e[m"
fi
if [ "$git_index_modified_count" ]; then
	marks+=" \e[97m";marks+="Mi:";marks+="\e[m"
	# style count as LIGHT YELLOW
	marks+="\e[93m";marks+="$git_index_modified_count";marks+="\e[m"
fi
if [ "$git_index_deleted_count" ]; then
	marks+=" \e[97m";marks+="Di:";marks+="\e[m"
	# style count as LIGHT RED
	marks+="\e[91\1m";marks+="$git_index_deleted_count";marks+="\e[m"
fi

if [ "$git_index_added_count" ] || [ "$git_index_modified_count" ] || [ "$git_index_deleted_count" ]; then
	if [ "$git_modified_count" ] || [ "$git_deleted_count" ]; then
		marks+=" |"
	fi
fi

if [ "$git_modified_count" ]; then
	marks+=" \e[97m";marks+="M:";marks+="\e[m"
	# style count as LIGHT YELLOW
	marks+="\e[93m";marks+="$git_modified_count";marks+="\e[m"
fi
if [ "$git_deleted_count" ]; then
	marks+=" \e[97m";marks+="D:";marks+="\e[m"
	# style count as LIGHT RED
	marks+="\e[91\1m";marks+="$git_deleted_count";marks+="\e[m"
fi

if [ "$git_untracked_count" ] || [ "$git_stashed_count" ]; then
	marks+=" |"
fi
if [ "$git_untracked_count" ]; then
	marks+=" \e[97m";marks+="untracked:";marks+="\e[m"
	# style count as LIGHT RED
	marks+="\e[91\1m";marks+="$git_untracked_count";marks+="\e[m"
fi
if [ "$git_stashed_count" ]; then
	marks+=" \e[97m";marks+="stashes:";marks+="\e[m"
	# style count as LIGHT YELLOW
	marks+="\e[93\1m";marks+="$git_stashed_count";marks+="\e[m"
fi

# print the git branch segment without a trailing newline
printf " [ $ref$marks ]"
}
